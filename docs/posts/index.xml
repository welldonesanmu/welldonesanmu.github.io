<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Sanmu</title>
    <link>https://welldonesanmu.github.io/posts/</link>
    <description>Recent content in Posts on Sanmu</description>
    <image>
      <title>Sanmu</title>
      <url>https://welldonesanmu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://welldonesanmu.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Mon, 13 May 2024 21:35:16 +0800</lastBuildDate><atom:link href="https://welldonesanmu.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>推荐系统的中 EMBEDDING 的应用实践</title>
      <link>https://welldonesanmu.github.io/posts/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD-embedding-%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Mon, 13 May 2024 21:35:16 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%AD-embedding-%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/</guid>
      <description>Word2Vec &amp;ndash; Item2Vec &amp;ndash; Graph Embedding Word2Vec Item2Vec Graph Embedding 1. DeepWalk 2014年的模型，主要思想是在物品组成的图结构上进行随机游走（Random Walk），产生大量物品序列，然后将这些物品序列作为训练样本输入Word2Vec进行训练，得到物品的Embedding。
DeepWalk算法流程：
2. LINE Large-scale Information Network Embedding
动机 这篇论文的初衷是解决两个问题：
大规模图节点的表示学习 有向、有权图的节点表示学习 无监督的，不使用神经网络架构的Graph Embedding技术。LINE 的方法是基于直接优化节点嵌入向量，通过显式定义的一阶和二阶相似性损失函数进行优化，而不涉及神经网络的多层结构或非线性变换。
3. Node2Vec 4. EGES 推荐系统中EMBEDDING的应用实践 - 卢明冬的博客 (lumingdong.cn)</description>
    </item>
    
    <item>
      <title>SDGCL</title>
      <link>https://welldonesanmu.github.io/posts/sdgcl/</link>
      <pubDate>Sat, 11 May 2024 17:59:03 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/sdgcl/</guid>
      <description>SDGCL 核心思想和主要贡献是提出了一个新颖的自监督学习框架——逐步扩散图对比学习（Stepwise Diffusion Graph Contrastive Learning, SDGCL），用于改进图上的节点分类性能。这个框架主要通过一个逐步扩散 (stepwise diffusion) 的过程生成多个增强视图，这一过程利用了单个神经网络的输出，从而能更有效地捕捉节点之间的复杂交互关系，同时减少了内存和计算负担 (使用一个参数矩阵这和堆叠多层的GraphSAGE等GNN模型相比，减少了n-1个W)。此外，这个框架还设计了一个逐步对比损失（stepwise contrastive loss），通过整合所有扩散视图中正负样本的比较，进一步提高了节点嵌入的区分度。
对比视图的Intuition Graph通常都是基于图同质性假设，但是异构图balabala。所以我们在一次call / forward中加入stepwise diffusion（本质是change A） 之后生成的中间embedding append并将这些中间层作为负样本，这样只需single layer就可以完成K-hop的长距离信息捕获（消融实验）。
Stepwise Contrastive Loss 设计 利用逐步扩散过程，从单一神经网络输出生成多个增强视图。对于每一个节点，其在不同视图中的表示构成正样本对，而与其他节点在相同或不同视图中的表示构成负样本对。对每一对节点嵌入（来自同一节点但位于不同扩散视图中），计算它们之间的相似度，并与其与其他节点（负样本）的相似度进行比较。
在讨论“逐步对比损失（Stepwise Contrastive Loss）”之前，我们先理解它所依据的基本原理：对比学习。对比学习主要是通过最大化相似（正）样本对之间的一致性，并最小化不相似（负）样本对之间的一致性来训练模型，以此学习数据的有效表示。
以下是具体实现：
与InfoNCE Loss和NT-Xent的区别 各部分Loss加权归一化后求和
Pivot view选择第一个视图，对于每一个视图来说（diffusion之后的embedding），把S步内的所有node也当做正样本（Future Work）！
两篇的区别？ 第一篇发现了这个特点之后，做了简单的实验发现结果也不错，使用多层堆叠的形式来生成多个对比视图（one layer one view）（自适应dropout，long range聚合进来的特征比例要小）
Graph Diffusion技术是怎么实现的？ Graph Diffusion 模拟信息在图中的传播来捕获节点之间的长距离关系。</description>
    </item>
    
    <item>
      <title>GraphSAGE</title>
      <link>https://welldonesanmu.github.io/posts/graphsage/</link>
      <pubDate>Sat, 11 May 2024 15:18:34 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/graphsage/</guid>
      <description>GraphSAGE Inductive Representation Learning on Large Graphs
两点强调：
Inductive Large Graphs 首先明确一个概念：在推荐系统中Graph embedding采用直推式或称推导式（transductive）和归纳式（Inductive）两种，区别就是对于一个新加入的节点，模型是否能够在不重新学习之前预训练好的embedding的情况下，对这个新加入节点的特征进行嵌入表征。
这个概念比较老，面试时不要被迷惑。
直推式 基于矩阵分解、DeepWalk、Node2Vec 归纳式 GraphSAGE、 GCN、 GAT、 GCLs 直推式这类方法通常包括直接优化节点嵌入的方法，如DeepWalk、Node2Vec等。这些方法在一个特定的图上学习节点的嵌入向量，并且假设训练时使用的所有节点在预测时都是可见的。这些方法的共同点是它们通常需要对图中所有节点进行处理，并且一次学习所有节点的嵌入。因此，它们通常不具备归纳能力，即难以直接应对图中新增节点的情况，除非重新进行嵌入的学习过程。 对于GCN是哪种范式一下就明了了，GCN通过学习一个卷积过程，其中节点的特征信息是通过其邻居的特征进行聚合更新的。这个过程允许GCN处理未见过的节点，所以是归纳式。但GCN的归纳能力取决于它的应用方式和具体的训练设置。例如，如果GCN在一个特定的图结构上训练，并且仅用于相同结构的图，则其行为更倾向于转导式学习。但如果其训练过程涵盖了多种图结构，并且模型设计上允许它适应不同的图，那么它就显示出强大的归纳能力。（多图案例是蛋白质结构预测） GCLs通常在无监督或自监督的设置下用于学习图或节点的表示。这种方法通过最大化正样本对的相似性和最小化负样本对的相似性来学习有效的嵌入。图对比学习的关键优势在于它不依赖于标签数据，而是通过数据本身的结构和内容来学习表示。这个也是归纳式的。 GraphSAGE（Graph Sample and Aggregation）是一种归纳式图神经网络模型，它设计用来生成节点的嵌入，即使是在训练过程中未见过的节点（这一点很好保证：1训练时隐藏节点2邻居采样）。这种归纳能力源于其独特的聚合机制，该机制能够从节点的局部邻域信息中学习如何有效地生成嵌入。
算法流程：
GraphSAGE实现归纳式学习的关键方面：
1. 局部邻域聚合 GraphSAGE的核心思想是使用聚合函数来合成一个节点的邻居信息，形成该节点的嵌入。这意味着生成节点嵌入不依赖于整个图的结构，而是依赖于每个节点的局部邻域。具体聚合函数可以是简单的均值聚合、池化聚合或LSTM聚合等。通过这种方式，模型可以灵活地应对图中的新节点，因为它只需要新节点的局部信息就能计算其嵌入。
2. 邻居采样 由于实际图往往非常大，直接使用所有邻居的信息进行聚合计算是不现实的。GraphSAGE引入了邻居采样策略，即从每个节点的邻居中随机选择一个固定大小的子集，然后只使用这些采样邻居的信息来进行聚合。这不仅减少了计算负担，而且通过随机性增加了模型的泛化能力。
3. 多层聚合 GraphSAGE通常使用多层聚合结构，每层都对应一个聚合步骤。每个节点在每一层聚合其邻居的信息，然后将聚合结果传递到下一层。这样，更高层的聚合可以间接包含更远邻居的信息。这种分层的聚合方式允许模型捕获从近邻到远邻的结构信息。
TensorFlow实现：
#!/usr/bin/env python # -*- coding:utf-8 -*- &amp;#34;&amp;#34;&amp;#34; 参考文献: [1] Hamilton W, Ying Z, Leskovec J. Inductive representation learning on large graphs[C]//Advances in Neural Information Processing Systems. 2017: 1024-1034. (https://papers.nips.cc/paper/6703-inductive-representation-learning-on-large-graphs.pdf) &amp;#34;&amp;#34;&amp;#34; import numpy as np import tensorflow as tf from tensorflow.</description>
    </item>
    
    <item>
      <title>字节一面</title>
      <link>https://welldonesanmu.github.io/posts/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/</link>
      <pubDate>Fri, 10 May 2024 17:48:28 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/%E5%AD%97%E8%8A%82%E4%B8%80%E9%9D%A2/</guid>
      <description>论文相关
详细实现（需要重新整理一版） 如果Graph Diffusion技术里 θ_k相当于是随机游走的概率因子的话，那和GraphSAGE有什么区别？ Loss是怎么实现的？和NCELoss的区别？ 两篇文章的区别是什么？ 对比视图的anchor选取？正负样本生成数量比例？ 对比学习常用的Loss是什么？ 使用Transformer去抽取图表征是否可行？ 了解GraphTransformer吗？ 推荐系统以及项目相关
推荐系统的架构实现是什么？ 召回层常用的什么算法？ Graph embedding怎么用在推荐上面的？ 在各个阶段，图神经网络怎么应用？ 召回层除了局部敏感哈希外还有什么方法加速召回？ AUC曲线的物理意义？AUC越高越好那么超过多少算是越高？ 说一下DIN的结构？ 项目中提到的会在排序层加入组合类别的神经网络，具体讲一下？ 手撕
使用rand5实现rand7。 给出一个数组，求出其中的逆序对个数；输出个数，数组中数字小于100000。 反问
部门实现推荐系统需要哪些技术栈？答：自研系统，服务端使用C++，模型搭建使用TensorFlow。 模型怎么上线耦合？答：算法工程师不管这个，有部门专门负责。 无Hadoop、Spark，all in算法实现
项目称之为练手
自我评价：C
Timeline：5.7&amp;ndash;5.10（等挂）
更新Timeline：5.11（挂同时被捞）</description>
    </item>
    
    <item>
      <title>English writing</title>
      <link>https://welldonesanmu.github.io/posts/english_writing/</link>
      <pubDate>Wed, 12 Apr 2023 15:02:38 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/english_writing/</guid>
      <description>Notes Move 1 Establishing a research territory Move 2 Establishing a niche Move 3 Presenting the present work </description>
    </item>
    
    <item>
      <title>2023.4.11</title>
      <link>https://welldonesanmu.github.io/posts/2023.4.11/</link>
      <pubDate>Tue, 11 Apr 2023 23:46:38 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/2023.4.11/</guid>
      <description>是你吗？ 今天给我的感觉已经像是触摸在云层中的样子了，可能是可能不是，可能触碰可能没有触碰，可能只剩下了一种阳光下开心微笑的剪影，也可能是Creep在心中回荡。
是真实的吗？
是虚假的吗？
现在愈发能感觉到Eason病态三部曲的滋味，WEIRDO WEIRDO WEIRDO。
很多东西都是纸里包着的一层，无论是身旁的人还是周围的人。
所以
是你吗？
还是自己吗？
4-11于深夜。</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://welldonesanmu.github.io/posts/git/</link>
      <pubDate>Mon, 10 Apr 2023 14:36:09 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/git/</guid>
      <description>Git 推送的用法及常见指令 echo &amp;ldquo;# Blog&amp;rdquo; &amp;raquo; README.md git init git add README.md git commit -m &amp;ldquo;first commit&amp;rdquo; git branch -M main git remote add origin git@github.com:welldonesanmu/Blog.git git push -u origin main
.md 文件换行：在每一行的末尾加上 &amp;ldquo;&amp;quot; ,然后再回车键。
新增了一个脚本，用于每次添加完之后自动deploy.</description>
    </item>
    
    <item>
      <title>2023.4.9</title>
      <link>https://welldonesanmu.github.io/posts/2023.4.9/</link>
      <pubDate>Sun, 09 Apr 2023 23:21:57 +0800</pubDate>
      
      <guid>https://welldonesanmu.github.io/posts/2023.4.9/</guid>
      <description>认识她的第9天 今天晚上看了电影，但是没有发给她，只在朋友圈发了一条复旦新闻馆动态，像预想的一样，没有收到任何评论和点赞。我深深呼吸了一口气，都是好事啦。</description>
    </item>
    
  </channel>
</rss>
